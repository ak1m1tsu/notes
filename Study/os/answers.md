# Ответы на вопросы
## **Основные концепции операционных систем.** 
### Понятие операционных систем, их классификация.
**Операционная система** - программа контролирующая работу прикладных программ и системных приложений и исполняющая роль интерфейса между приложениями и аппаратным обеспечением компьютера.
По назначению:
* Общего назначения
* Реального времени
* Встроенные в оборудование
* Специализированные

По области использования:
* Настольные
* Серверные
* Специализированные

По характеру взаимодействия с пользователем:
* Пакетные, обрабатывающие заранее подготовленные задания
* Системы разделения времени
* Встроенные

По числу одновременно выполняемых задач:
* Однозадачные
* Многозадачные
По числу пользователей:
* Однопользовательские
* Много пользовательские

По аппаратной платформе:
* ПК
* Кластеров
* Мобильные

По типы многозадачности:
* Вытесняющая многозадачность
* Не вытесняющая многозадачность
### Типовые архитектуры ОС. 
**Ядро (kernel)** - часть ОС, которая обеспечивает приложениям координированный доступ к ресурсам компьютера. Также **ядро** обычно представляет сервисы файловой системы и сетевых протоколов
Выделяют два режима работы для приложений и т.д.:
1. Пользовательский режим (приложения пользователя и т.д.)
2. Привилегированный режим (ядро, HAL, драйвера)

Выделяют следующие архитектуры ядер ОС:
1. Монолитное ядро
2. Модульное ядро
3. Микроядро

**Монолитное ядро** - схема ОС, при которой все ее компоненты являются составными частями одной программы, используют общие структуры данных и взаимодействуют друг с другом путем непосредственного вызова процедур.
Плюсы:
* Скорость работы
* Упрощенная разработка модулей

Минусы:
* Сбой в одном из компонентов может нарущить работоспособность всей системы

**Модульное ядро** - усоверщенствованная модификация архитектуры монолитных ядер. 
В отличие от монолитных ядер, как правило, не требуют польной перекомпиляции ядра при изменении состава аппаратного обеспечения компьютера. Вместо этого модульные ядра предоставляют тот или иной механизм подгрузки модулей ядра, поддерживающих то или иное аппаратное обеспечение (драйвер и т.п.).

**Микроядро** представляет собой только элементроаные функции управления процессами и минимальный набор абстракций для работы с оборудованием. Критерием *микроядерности* является размещение большинства драйверов и модулей в сервисных процессах.
Плюсы:
* Устройчивость к сбоям оборудования, ошибка в компонентах системы.
* Высокая степень модульности ядра ОС (легко добавнить новые компоненты)
* Упрощается процесс отладки компонентов ядра, т.к. новая версия драйвера может загружаться без перезапуска всей ОС.

Минусы:
* Передача данных между процессами требует больших расходов чем при *классических* ядрах.
### Архитектура современных версий ОС Windows. 
**Режим ядра** имеет польный доступ к аппаратной части компьютера и системным ресурсам. Работает в защещенной области памяти.
К компонентам режима ядра в Windows относят:
1. Исполнительная система Windows
2. Ядро Windows
3. Драйвера устройства
4. Уровень абстрагирования от оборудования (HAL), изолирующий ядро, драйверы и исполнительную систему Windows от аппаратной части
### Концепции системных вызовов, исключительных ситуаций, прерываний. 
**Системный вызов** - обращение программы к ядру ОС для выполнения операции. При вызове задача переходит в привилегированный режим.

**Исключительная ситуация** - событие, которые возникает в результате выполнения программой команды, которая по каким-то причинам не может быть выполнена до конца.

**Прерывание** - сингал, сообщающий процессу о соверщении асинхронной операции. При этом процессор должен приостановить текущее выполнение комманд, а усправление передать обработчику прерываний.
Прерывания делять на 4 класса:
1. Программные прерывания - генерируются самой программой, например, при возникновении ошибки.
2. Прерывания по таймеру - генерируются спец. устройством внутри ПК через определенные промежутки времени
3. Прерывания ввода-вывода - генерируются контроллером ввода-вывода. Сигнализируют о нормальном завершении или об ошибке
4. Аппаратные прерывания - генерируеются в ситуациях, связанных с аппаратурой, например, отсутсвие блока в памяти.
### Хэширование. 
**Хеширование** - алгоритм преобразования данных в *битовую строку (хеш-сумму)* фиксированной длины. Алгоритмы хеширования обладают свойством *необратимости*, т.е., зная битовую строку, не возможно будет по ней получить данные обратно.
Если алгоритм хеширования при разных данных выдал одинаковые битовые строки, то такая ситуация называется - **коллизией хеш-функций**.
*Хешированние* используется для сверки паролей пользователей и для ускорения поиска данных.
Для сверки используется хеш-значение проверяемой информации, которая используется при:
1. Проверки на наличие ошибок
2. Проверка парольной фразы
3. Проверка электронной подписи
### UUID.
**UUID** - стандарт инедтификации, которые ползволяет взаимодействующим системам уникально идентифицировать информацию без центра координации. Изображают данный дентификатор в виде числа в 16-ой СС в формате 8-4-4-4-12. **GUID** же - отдельный стандарт UUID, созданный *Microsoft*
## **Процессы и потоки выполнения**.
### Понятие процесса.
**Процесс** - совокупность исполняющихся команд ассициированных с ними ресурсов и текущего момента его выполнения, находящуюся под управлением ОС.
### Классификация процессов.
Процессы классифицируют по следующим признакам:
1. Ограничения по времени
	1. Реального времени - процессы, которые требуют полное выполнение к некоторому моменту времени
	2. Интерактивные - процессы, время выполнения которых должно улкадываться в определенный интервал времени.
	3. Фоновые - нет временных ограничений.
2. Параллельность
	1. Параллельны, если интервалы их существования пересекаются во времени
	2. Последовательны
3. Иерархия
	1. Родительский
	2. Дочерний
4. Принадлежность к ОС
	1. Пользовательские
	2. Системные
5. Связанность
	1. Взаимосвязанные, если существуют функциональные, управляющие, информационные или временные связи.
	2. Изолированы
### Состояния процессов.
Изначально процессы имели два состояние: выполняются, не выполняются. После появилось третье состояние: блокированные.
В настроящее время выделяют следующие состояния процессов:
1. Новые
2. Готовые к выполнению
3. Выполняющиеся
4. Блокированные
5. Приостановленные
6. Заверщающиеся
### События создания и завершения процессов.
Причины для создания процесса:
1. Новое пакетное задание
2. Вход в систему в интерактивном режиме
3. Создание ОС процесса, необходимого для работы служб
4. Порождение одго процессаа другим

Виды завершений процесса:
1. Номарльное (добровольное)
2. Завершение вследствие ошибки (добровольное)
3. Завершение вследствие фатальной ошибки (принудительное)
4. Запрос от пользователя (принудительное)
5. Уничтожение другим/родительским процессов (принудительное)
6. Завершение родительского процесса (принудительное)
### Переменные окружения.
**Переменные окружения** - специальные текстовые переменные, определенные оболочкой и используемые программами во время выполнения.
Выделяют три вида переменных окружения:
1. Системные переменные
2. Пользовательские переменные
3. Локальные переменные
### Понятие потока.
**Поток** - единица вычислений, которая управляется ОС. Они были созданные как средство распараллеливания вычислений, которое учитывало бы тесные связи между отдельными ветвями вычисмлений одного и того же приложения. ОС распределяет процессорное время между потоками, а также для процесса назначается адресное пространство и набор ресурсов, которое используют всеми его потоками.
### Потоки ядра и потоки пользователя.
**Потоки на уровне ядра**
Преимущества:
1. Реализуют многозадачность на нескольких процессорах
2. При блокировке одного из потоков процесса ядро может выбрать для выполнения другой поток этого же процесса

Недостатки:
1. Многократное переключение между режимами пользователя и ядра при переключении между потоками
2. Ограниченность в создании (несколько тысяч)

**Потоки на уровне пользователя**
Преимущества:
1. Высокая производительность
2. Возможность использования различных алгоритмов планирования
3. Можно делать десятки и сотни тысяч

Недостатки:
1. В ОС многие системные вызовы являются блокирующими, из-за чего системный вызов одного потока может превести к блокировке остальных
2. Приложение не сможет воспользоваться преимуществом многопроцессорной системы
3. При запуске одного потока ни один другой поток не будет запущен, пока первыей добровольно не отдаст процессор
### Системные вызовы.
**Системный вызов** - обращение программы к ядру ОС для выполнения операции. При вызове задача переходит в привилегированный режим.
## **Асинхронное и синхронное выполнение**. 
### Понятие процесса.
**Процесс** - совокупность исполняющихся команд ассициированных с ними ресурсов и текущего момента его выполнения, находящуюся под управлением ОС.
### Понятие потока.
**Поток** - единица вычислений, которая управляется ОС. Они были созданные как средство распараллеливания вычислений, которое учитывало бы тесные связи между отдельными ветвями вычисмлений одного и того же приложения. ОС распределяет процессорное время между потоками, а также для процесса назначается адресное пространство и набор ресурсов, которое используют всеми его потоками.
### Потоки ядра и потоки уровня пользователя.
**Потоки на уровне ядра**
Преимущества:
1. Реализуют многозадачность на нескольких процессорах
2. При блокировке одного из потоков процесса ядро может выбрать для выполнения другой поток этого же процесса

Недостатки:
1. Многократное переключение между режимами пользователя и ядра при переключении между потоками
2. Ограниченность в создании (несколько тысяч)

**Потоки на уровне пользователя**
Преимущества:
1. Высокая производительность
2. Возможность использования различных алгоритмов планирования
3. Можно делать десятки и сотни тысяч

Недостатки:
1. В ОС многие системные вызовы являются блокирующими, из-за чего системный вызов одного потока может превести к блокировке остальных
2. Приложение не сможет воспользоваться преимуществом многопроцессорной системы
3. При запуске одного потока ни один другой поток не будет запущен, пока первыей добровольно не отдаст процессор
### Системные вызовы.
**Системный вызов** - обращение программы к ядру ОС для выполнения операции. При вызове задача переходит в привилегированный режим.
### Асинхронное и синхронное выполнение потоков.
**Синхронность** - последовательное выполнение операций: пока не будет завершена операция, все процесс выполнения останавливается и ждет.
**Ассинхронность** - выполнение операций без блокировки алгоритма: при завершении операции процесс каким-либо способом информируется.
### Механизмы асинхронного выполнения (колбэки, футуры, промисы, await/async процедуры).
**Корутины** - функция, которая при возврате результата способна сохранять текущее состояние и при повторном вызове она может начинаться с места, где был сделан возврат результата.
**Callback** - функция, которая вызвается после завершения ассинхронной операции.
**Promise** - объект, который содержит будущее значение ассинхронной операции и, в зависимость от состояния, вызвает определенный код. На Promise вешается два callback'a: если закончилось хорошо / плого и когда асинхронный метод вернет promise, автоматически вызовется соответствующие обработчик во внешнем коде.
**Чейнинг** - выстраивание промисов в цепочку. Когда промис в случае удачи или неудачи возвращает другой промис.
**Future** - объект, который может быть вычислен в неизвестное для потока время. Поток, который хочет получить результат Future блокируется, если его значение еще не определенно.
**Await**/**async** - async помечает функцию, как асинхронную, а wait используется для отметки строк кода, которые должны быть выполненны ассинхронно.
## **Планирование процессов и потоков**. 
### Понятие процесса.
**Процесс** - совокупность исполняющихся команд ассициированных с ними ресурсов и текущего момента его выполнения, находящуюся под управлением ОС.
### Понятие потока.
**Поток** - единица вычислений, которая управляется ОС. Они были созданные как средство распараллеливания вычислений, которое учитывало бы тесные связи между отдельными ветвями вычисмлений одного и того же приложения. ОС распределяет процессорное время между потоками, а также для процесса назначается адресное пространство и набор ресурсов, которое используют всеми его потоками.
### Потоки ядра и потоки уровня пользователя.
**Потоки на уровне ядра**
Преимущества:
1. Реализуют многозадачность на нескольких процессорах
2. При блокировке одного из потоков процесса ядро может выбрать для выполнения другой поток этого же процесса

Недостатки:
1. Многократное переключение между режимами пользователя и ядра при переключении между потоками
2. Ограниченность в создании (несколько тысяч)

**Потоки на уровне пользователя**
Преимущества:
1. Высокая производительность
2. Возможность использования различных алгоритмов планирования
3. Можно делать десятки и сотни тысяч

Недостатки:
1. В ОС многие системные вызовы являются блокирующими, из-за чего системный вызов одного потока может превести к блокировке остальных
2. Приложение не сможет воспользоваться преимуществом многопроцессорной системы
3. При запуске одного потока ни один другой поток не будет запущен, пока первыей добровольно не отдаст процессор
### Системные вызовы.
**Системный вызов** - обращение программы к ядру ОС для выполнения операции. При вызове задача переходит в привилегированный режим.
### Переменные окружения.
**Переменные окружения** - специальные текстовые переменные, определенные оболочкой и используемые программами во время выполнения.
Выделяют три вида переменных окружения:
1. Системные переменные
2. Пользовательские переменные
3. Локальные переменные
### Механизм планирования потоков.
**Планирование процессов** - определение очередности получения ресурсов вычислительной системы для процессов при их активации
Выделяют при тип планирования процессов:
1. Долгострочне планирование
2. Среднесрочное планирование
3. Краткосрочное планирование

**Догосрочное планирование** осуществялется при создании нового процесса и представляет собой решение о добавлении нового процесса к множеству активных в данный момент процессов. 
Также оно указывает, какие программы допускаются к выполнению системой, и тем самым определяет степень многозадачности.
**Среднесрочное планирование** представляет собой решение о добавлении процесса к множеству процессов, которое хотя бы частично расположены в основной памяти. Также данное планирование является частью системы управления виртуальной памяти.
**Краткосрочное планирование** представляет собой решение о том какой из готовых в выполнению процессов будет выполняться следующим.
### Планирование в Windows.
Windows не имеет какого-то отдельного приложения, которое занимается планированием. Для этого в Windows есть поток простоя.
Планирование выполняется в случаях, когда поток блокируется либо истекает квант времени выполнения. Используется кругова стратегия, связанная с очередями, с использованием приоритета.
В Windows существует 32 уровня приоритета, где 16-32 уровень - приоритет реального времени, 1-15 уровень - приоритет для обычных потоков и 0 уровень для системного потока.
Если нет ни одного к выполнению потока, то ос подключает поток простоя, которые загружает ос, когда они ничем не занята. У данного потока отсутствует приоритет.
Для потоков уровня 1-15 Windows может кратковременно увеличивать их уровни приоритетности. Это происходит при завершении операций ввода-вывода, для того чтобы заброкированный поток успел все закончить.
## **Управления процессами в ОС класса Linux**.  
### Запуск, остановка, приостановка и изменение приоритета процесса.
Процесс запускается после запуска программы, утилиты и пр. Остановить процесс можно сочетанием клавиш **Ctrl+C**, командой **kill**, отправив процесс соответствующий сигнал. Изменение приоритета процесса выполняется с помощью команды **renice** (renice *value* -p *pid*), также для запуска программы с каким-то приоритетом используется команда **nice** (nice -n *value* *command*). Приостановить процесс можно при помощи сочетания клавиш **Ctrl+Z**.
### Просмотр списка процессов.
Просмотр списка процессов осуществляется при помощи команды **ps**, **top**
### Автозапуск процессов при старте системы.
Добавление службы в автозагрузку можно сделать с помощью команды sudo **systemctl** **enable** *service*
### Периодический запуск процессов.
Периодический запуск процессов можно настроить с помощью **crontab**
## **Межпроцессное взаимодействие**. 
### Ресурсы вычислительной системы.
**Ресурс** - средство вычислительной системы, которое выделяется процессу на определенный момент времени для его успешной работы.
### Методы взаимодействия процессов.
Способы взаимодействия процессов:
1. Процессы не осведомлены о наличии друг друга – конкуренция в борьбе за ресурсы
2. Процессы косвенно осведомлены о наличии друг друга – сотрудничество с разделением
3. Процессы непосредственно осведомлены о наличии друг друга – сотрудничество с использованием связи
### Средства обеспечения взаимоисключений.
**Взаимоисключение** – ситуация, в которой существует множество процессов, но получить доступ к некоторому ресурсу или выполнить некоторую функцию в определенный момент может только один из них.
**Критическая секция** – часть программы, результат выполнения которой может непредсказуемо меняться, если она будет выполняться двумя потоками/процессами одновременно (например, два потока одновременно поменяют значение какой-то глобальной переменной).
**Взаимная блокировка** (deadlock) – ситуация, когда несколько процессов ждут ресурс, который не может быть освобожден, потому что занят процессом, который находится в аналогичном состоянии.
**Голодание** - когда выполнение процесса бесконечно откладывается, потому что приоритет выполнения отдается другим процессам
**Гонка** - ситуация, когда два или более процесса/потока рыботают с какими-то общими ресурсами, но конечный результат зависит от соотношения скоростей.
Требования к поддержке взаимоисключений:
1. Взаимоисключения принудительны (если говорим, что зайти нельзя, то это правило нельзя игнорировать)
2. Если процесс завершается вне критической секции, то это не должно влиять на остальные процессы
3. Не должна возникать ситуация бесконечного ожидания освобождения критической секции (должно быть ограничение по времени)
4. Если в критическом разделе нету ни одного процесса, то любой процесс может получить доступ мгновенно
5. Не делаются предположения о количестве процессов и потоков\

Способы контроля взаимоисключений:
1. **Семафор** - числовое значение, используемое для передачи сигналов между процессами. Если процесс делает операцию wait (хочет зайти в крит. секцию), то значение семафора уменьшается на единицу. Если значение переменной семафора становится отрицательным, то процесс, выполняющий операцию wait блокируется. Операция signal (выход из крит. секции) увеличивает значение семафора на 1. Если значение семафора >= 0, то заблокированный процесс разблокируется.
3. **Мьютекс** - упрощенная версия семафора, которая может находится только в двух состояниях: блокированный или разблокированный. Мьютекс может стать покинутым (процесс, который сейчас выполнялся сдох), если это случилось, то ОС должна сообщить всем процессам/потоком о том, что ждать дальше нет смысла.
4. **Локи** - тоже самое, что мьютексы, но реализован не на уровне ОС, а не уровне библиотек ЯП и работает только с потоками одной программы
### Средства синхронизации процессов.
Способы общения процессов:
1) Разделяемая память (shared memory) – с помощью средств ОС создается общая область оперативной памяти, куда могут писать и читать процессы. Обычно если область пустая, то процесс блокируется, но необязательно
2) Сообщения (mailbox) – у каждого процесса есть почтовый ящик, куда он может принимать сообщения (очередь). Из этой очереди процессу отдаются сообщения и на каждый тип сообщения можно повесить свой обработчик. В windows есть сообщения о движение мышки, нажатие клавиши и т.д. (можно забиндить в c# winforms).
3) Каналы – по факту файл (который не видно), в который одна программа пишет, а вторя читает. Если читающая программа не найдет информации в канале, то она будет заблокирована, пока информация не появится. В канале может быть буфер и пишущая программа может записать сразу порцию данных, а читающая будет постепенно их читать. Именованные программы используются для взаимодействия двух разных программ, а не именованная между потоками одной программы. На уровне ЯП есть фреймворки для каналов, с помощью которых взаимодействуют зеленые потоки
4) Сигналы – механизм, который говорит о наступление какого-либо события. Является просто числом. В программах можно весить обработчики сигналов. Пример сигнала: SIGALARM – сигнал часов, можно чтоб через определенное время шел этот сигнал и обрабатывался (в C# таймер реализован как раз с помощью него). Единственный сигнал, на который нельзя повесить обработчик – SIGKILL (9), т.к. он мгновенно убивает программу
5) Сокеты (socket) – в отличие от предыдущих, позволяет взаимодействовать по сети. Когда что-то делаем в браузере, что-то качаем через торрент и вообще все взаимодействия по сети – это сокеты. Есть два вида: datagram и потоковые. Один работает по TCP (все пакеты точно дойдут), а другой по UDP (если не дошло, то пофиг, за счет чего все быстрее)
## **Управление памятью**. 
### Типы адресов памяти.
Выделяют три тип адресов памяти:
1. Символьные - переменные, созданные программистом
2. Виртуальные - создаются транслятором при компиляции ЯП в машинный код
3. Физические - указывает на ячейку памяти в ОЗУ
### Виртуализация памяти.
**Виртуализация памяти** - процесс создания ресурса, который предоставляется пользователю или программе обладая свойствами, коорыми он в действительности не обладает. При вируализации предоставляется виртуальная ОЗУ, объем которой превышает объем физической ОЗУ. Для хранения данных виртуальная память исползует внешние запоминающие устройства и выгружает их в физическую ОЗУ при необходимости.
Существует два подхода виртуализации памяти:
1. **Свопинг (swoping)** - процесс перемещения образа процесса целиком на жесткий диск и обратно
2. **Виртуальная память** - процесс перемещения части образа процесса 

Задачи виртуализации:
1. Размещение данные в ЗУ разного типа
2. Выбор образов процессов/их частей для перемещения из ОЗУ на носитель и обратно
3. Перемещение данных между памятью и диском
4. Преобразование виртуальных адресов в физические

В настоящее время существуют три подхода к работе с виртуальной памятью:
1. Страничная организует перемещение данных между паматью и диском страницами - частями виртуального адресного пространства, фиксированного и сравнительно небольшого размера
2. Сегментная предусматривает перемещение данных сегментами - частями вирутального адресного пространства произваольного размера, полученными с учетом смыслового значения данных
3. Сегментно-страничная использует двухуровневое деление: виртуальное адресное пространство делится на сегменты, а затем сегменты делятся на страницы
### Страничная память.
Для того, чтобы хранить на диске страницы существует специальный файл или раздел, который называют файл свопинга
Все виртуальное пространство делится на страницы одинакового размера. В виртуальной памяти они называются страницы, а в физической кадрами. Каждый кадр содержит одну страницу данных.
Система отображения виртуальных адресов физически представляет собой таблицу, где показывается, что есть такой-то адрес виртуальной памяти и где он физически находится, в ОЗУ или на диске. Сама таблица хранится в ОЗУ.
Дискриптор - строка таблицы страниц и включается в себя:
1. Признак присутствия
2. Признак модификации
3. Признак обращения к странице
4. Бит защиты
5. Бит запрета кэширования
6. Номер физической страницы, в которую загружена виртуальная страница
### Управление памятью Windows.
Управлением паматью в Windows занимается диспетчер управления памятью. Он умеет мапить виртуальные адреса в физические, свопинг и предоставляет базовый набор сервисов для подсистем Windows.
## **Виртуализация**. 
### Где применяется. 
Виртуализация применяется оыбчна в области серверов, систем хранения данных и т.д.
### Виды виртуализации. 
Выделяют следующие виды виртуализации:
1. Виртуализация серверов - позволяет на ожной физической машине запускать несколько виртуальных
2. Виртуализация рабочих мест - когда у нас наше рабочее место находится где-то на каком-то сервере, а доступ к нему мы получаем через какое-то приложение и через какую-то аппаратуру
3. Виртуализация локальной сети - эмуляция технологий передачи данных, для шифрования трафика данных
4. Виртуализация приложений - запускать приложения написанные для одной ОС на другой ОС
5. Виртуализация систем хранения данных - позволяет с легкостью управлять любым объемом данных и мигрировать их между физ. носителями
### Преимущества и недостатки. 
Преимущества виртуализации:
1. Экономический эффект
2. Меньше функций администрирования
3. Простая миграция и модернизация *железа*
4. Высокая отказоустройчивость
5. Гибкое распределение производительности на физические сервера
### Виртуализация рабочих мест. 
**Виртуализацитя рабочих мест** представляет собой перенос пользовательских рабочих мест в виртуальное пространство. Рабочее место отвязывается от аппаратных компонентов, а вычисления выполняются не на конкретном пользовательском устройстве, а на цетральном сервере или облаке.
### Виртуализация локальной сети. 
**Виртуализация локальной сети (VPN)** - совокупность технологий, позволяющих обеспечить несколько сетевых соединений поверх другой сети.
VPN применяют для:
1. Удаленной работы
2. Объединения разных частей компании
3. Внутри компании
4. Обхода заблокированных сайтов
5. Анонимности
6. Шифрование трафика
### Серверная виртуализация. 
**Серверная виртуализация** - архитектура ПО, которая обеспечивает работу нескольких ОС на одном физ. сервере. При этом ПО каждого сервера самостоятельно и отделено от любых физ. устройств.
### Виды гипервизоров.
**Гипервизор** - средство для создания виртуальных ОС.
Функции гипревизора:
1. Изолирует виртуалки, выделяя им память, переключая контекст между состояниями
2. Эмулирует устройства и управляет доступом
3. Выполняет привелигированные операции в виртуалках
4. Управляет жизненым цивлом виртуалок

Выделяют два тип гипервизоров:
1. Загружается над физ. уровнем, как ОС. Может управлять физическими русерсвми напрямую.
2. Исползует ресуры и функции хост-ОС, а действует как ПО над ОС.

**Гипервизор 1** типа не соперничает за ресурсы с ОС, в сравнении с **гипервизором 2**, из-за чего на сервере доступно больше ресурсов -> больше виртуалок. Также он является более безопасным, т.к. виртуалки делают запросы ресурсов, которые обрабатываются вне данной виртуалки, и поэтому они никак не влияют на другие виртуалки. Но гипервизор 2 тип удобен и легок в использовании
### Контейнерная виртуализация.
**Контейнерная виртуализация** - является гипервизором 2 типа, только вместо виртуалок создает **контейнеры** - неполноценные ОС, т.к. они не сохраняют свое состояние и занимают очень мало места.
Преимущества:
1. Мало весят
2. Быстро запускаются
3. Неизменяемые

Недостатки:
1. Конкуренция за ресурсы
2. Хуже совместимость
3. Не хранят данные
4. Не пригодны для крупных монолитов
### Docker, docker-compose, kubernetes.
**Docker Compose** — это инструментальное средство, входящее в состав **Docker**. Оно предназначено для решения задач, связанных с развёртыванием проектов. Нужно чтоб запускать сразу несколько взаимосвязанных контейнеров.
**Kubernetes** (K8s) — это программная платформа для автоматического управления контейнеризованными приложениями.
## **Ввод-вывод**. 
### Подсистема ввода-вывода ОС. 
Принципы подсистемы ввода-вывода
1. Устройства ввода-вывода должны работать параллельно
2. Должна присутствовать согласованность и кэширование данных
3. Разделение устройств между процессами
4. Предоставление удобного интерфейса к устройствам
5. Поддержка широкого спектора драйверов и возможность добавления нового
6. Динамическая загрузка и выгрузка драйверов
7. Поддержка нескольких ФС
8. Поддержка ассинхронной и сихнронной операции ввода-вывода
### Прерывания. 
Сигнал, сообщающий процессору о совершении ассинхронной операции, при это процесс приостанавливает текущее выполнение команд, а управление передается обработчику прерываний.
### Способы осуществления ввода-вывода (PIO, IIO, DMA).  
Выделяют три способа осуществления ввода-ввывода:
1. Программируемый ввод-вывод (PIO)
2. Ввод-вывод с прерываниями (IIO)
3. Прямой доступ к памяти (DMA)

При **PIO** процессор передает каждый блок команд контроллеру и ждет, пока устройство закончит работу и вернет результат.
При **IIO** процессор передает блоки команд контроллеру и продолжает выполнение других операций. Как только контроллер закончит работу, процессор прервется чтобы получить результат.
При **DMA** контроллер ждет пока нужны данные попадут в выделенную область ОЗУ, а по завершению процессор прервется чтобы обработать результат.
### Структура программной части управления вводом-выводом ОС. 
Пользователь при помощи ПО делает запрос к драйверу устройства, который передает команды контроллеру (драйвер блокируется). После выполнения операции обработчик прерываний разблокирует драйвер, который вернет результат операции.
### Драйверы. 
Драйвер - программа которая является посредником между ОС и аппаратным обеспечением. Он обрабатывает прерывания от контроллера. Предоставляет API для разработчика и взаимодействует с другими частями ОС
### Принципы работы независимого от устройств ПО ОС: кэширование, буферизация, обработка ошибок, монопольный захват устройств, спулинг.
**Буферизация** - область ОЗУ, в которой временно хранятся данны при их передаче между двумя устройствами или между устройством и приложением. Она помогает согласовать скорость между отправителем и получателем потока данных.
**Кэш-память** - реализованная в процессоре память, в которой хранятся копии исходных данных. Идея *кэширования* в том, что недавно использованные данные должны быть сохранены в кэш-памяти, чтобы при повторном обращении пользователя к тем же данным они могли обрабатываться локально, при этом скорость доступа к этим данным значительно возрастает.
**Обработка ошибок** дожна происходить как можно ближе к оборудованию. Сначало ошибку пытается обработать контроллер устройства, потом драйвер, после ОС. Если ОС не смогла обработать, то выводится сообщение пользователю об ошибке.
**spooling** — способ организации вычислительного процесса, при котором данные сначала буферизируются, а только потом передаются устройству для их обработки. По окончании обработки данных, на устройство посылается следующая порция данных, стоящая в очереди первой.
**Монопольный захват** - ситуация, где один процесс получает в монопольное распоряжение какое-либо устройство, при этом другие процессы при попытке обратиться к этому устройству блокируются, либо получают сообщение о невозможности выполнения, пока процесс, захвативший устройтсво, не доделает свои дела или откажется от его использования.
## **Загрузка ОС**. 
### Прерывания. 
Сигнал сообщающий процессу, о том что нужно приостановить текущее выполнение команд. После чего управление перейдет обработчику прерываний.
### Драйверы. 
Драйвер - программа которая является посредником между ОС и аппаратным обеспечением. Он обрабатывает прерывания от контроллера. Предоставляет API для разработчика и взаимодействует с другими частями ОС
### Принципы работы независимого от устройств ПО ОС: кэширование, буферизация, обработка ошибок, монопольный захват устройств, спулинг. 
**Буферизация** - область ОЗУ, в которой временно хранятся данны при их передаче между двумя устройствами или между устройством и приложением. Она помогает согласовать скорость между отправителем и получателем потока данных.
**Кэш-память** - реализованная в процессоре память, в которой хранятся копии исходных данных. Идея *кэширования* в том, что недавно использованные данные должны быть сохранены в кэш-памяти, чтобы при повторном обращении пользователя к тем же данным они могли обрабатываться локально, при этом скорость доступа к этим данным значительно возрастает.
**Обработка ошибок** дожна происходить как можно ближе к оборудованию. Сначало ошибку пытается обработать контроллер устройства, потом драйвер, после ОС. Если ОС не смогла обработать, то выводится сообщение пользователю об ошибке.
**spooling** — способ организации вычислительного процесса, при котором данные сначала буферизируются, а только потом передаются устройству для их обработки. По окончании обработки данных, на устройство посылается следующая порция данных, стоящая в очереди первой.
**Монопольный захват** - ситуация, где один процесс получает в монопольное распоряжение какое-либо устройство, при этом другие процессы при попытке обратиться к этому устройству блокируются, либо получают сообщение о невозможности выполнения, пока процесс, захвативший устройтсво, не доделает свои дела или откажется от его использования.
### Устройства хранения информации. 
Устройства хранения информации должны:
1. Хранить большие объемы данных
2. Уметь сохранять данные после прекращения работы процесса, который их создал
3. Несколько процессов должны иметь возможность одновременно работать с файлами
### MBR и GPT. 
Структура **MBR**
![[mbr.png]]
Особенности:
1. Существует специальный отдел, в котором должен нахоидтся загрузочный код
2. Максимальный размер раздела 2.2 Тб
3. Работает с BIOS
4. Можно создать только 4 основных раздела, либо 3 основных и 1 дополнительный (для логических)

Стукртура **GPT**
![[gpt.png]]
Особенности:
1. Работает с UEFI
2. Масимальный размер раздела ограничивается ОС
3. Максимальное кол-во разделов ограничивается ОС
4. Загрузочный код имеет backup'ы, которые расположены в разных местах
### Системный загрузчик Windows и порядок его работы.
**Системный загрузчик Windows** представляет собой файл загрузчик и файлы конфигурации расположенные с специальном разделе размером 100-500 мб.

Сначало запускается **BIOS**, а после загрузчик Windows
Порядок работы загрузчика:
1. Загружает драйвера ФС
2. Если система находится в спящем режиме, то запускает файл `winresume.exe`, который восстанавливает ОС в прежнее состояние.
3. Считывается файла конфигурации, если в нем находится несколько ОС то выводится окно выбора ОС
4. Ищатся файлы ядра
5. Просматривается реестр драйверов, необходимых для загрузки
6. Загружаются драйвера
7. Запускается ядро

Порядок работы ядра:
1. Загружает оставшиеся драйвера
2. Подготавлевает систему для обработки приложениями
3. Запускает диспетчер системных сеансов

Порядок работы диспетчера системных сеансов:
1. Запускает подсистему Windows
2. Инициализирует переменные окружения
3. Запускает программы проверки дисков и т.д.
4. Удаляет, перемещает, копирует необходимые файлы до полной загрузки

Порядок работы подсистемы Windows:
1. Запускает процесс подсистемы среды (`csrss.exe` отвечает за вспомогательные вещи по типу `GUI`, выключения ОС)
2. Запускает драйвер который инициализирует диспетчер окон, библиотеки `DirectX` и прочие графические библиотке
3. Хост-процесс консоли для работы с консольными приложениями
4. Различные `DLL`

Вместе с процессом подсистемы среды стартует `winlogon.exe`, который отвечает за авторизацию пользователя в систему, управление службами.
## **Управление файлами**. 
### Задачи системы управления файлами ОС.
**Система управления файлами** - комплекс программ, которые позволяют работать с файлами.
Задачи:
1. Управлять файлами
2. Оптимизировать работу
3. Подержка разных устройств ввода-вывода
4. Минимизация возможных потерь данных
### Файлы.
**Файл** - именнованная область внешнего запоминающего устройства, в которую можно записать и из которой можно считать данные
### Типы файлов.
Выделяют три типа файлов:
1. Обычные
2. Специальный (дрейвер и т.п.)
3. Каталог
### Стандартные потоки.
Существует три стандартных потока:
1. Стандартный поток ввода
2. Стандартный поток вывода
3. Стандартный поток ошибок

**Стандартный поток ввода** зарезервирован для чтения команд с консоли.
**Стандартный поток вывода** зарезервирован для отображения информация (чаще всего в виде текста)
**Стандартный поток ошибок** зарезервирован для отображения ошибок в текстовом формате
### Именование файлов.
Именование файлов:
1. Простое (название + расширение)
2. Полное (От корневого каталога до простого названия)
3. Относительное (От текущего каталога до простого названия)
### Атрибуты файлов.
Выделяют следущие атрибуты файлов:
1. Идентификатор владельца и создателя
2. Дата создания и модификации
3. Тип файла
### Операции над файлами.
Операции над файлами:
1. создание
2. удаление
3. открытие
4. закрытие
5. чтение
6. запись
7. поиск
8. копирование
9. получить атрибуты
10. установить атрибуты
11. переименовать
### Директории и операции над ними.
Операции с каталогами
1. создание
2. удаление
3. открытие
4. закрытие
5. переименование
6. копирование
7. создание ссылки
8. удаление ссылки
## **Управления файлами в ОС класса** **Linux**.  
### Работа с каталогами и файлами.
Просмотр содержимого файла - `cat`
Вывод первы строк - `head`
Вывод последних строк - `tail`
Просмотр содержимого каталога - `ls`
Удаление каталога - `rm -r` / `rmdir`
Создание каталога - `mkdir`
Удаление файла - `rm`
Создание файла - `touch`
Копирование файла - `cp`
Перемещение файла - `mv`
Создание ссылки на файл / каталог - `ln`
Поиск по тексту файла и т.п. - `grep`
### Типовые задачи: поиск, архивирование, резервное копирование.
Поиск файлов при помощи утилит `find` или `locate`
Архивирование при помощи утилиты `zip` и разархивирование - `unzip`
Резервное копирование при помощи утилиты `tar -cz` (создаем архив без каталога с виртуальными файловыми системами и домашним каталогом)
### Система привилегий.
В Linux существуеют следующие параметры доступа:
1. Чтение
2. Запись
3. Выполнение

Для каждого файла существуют три категории пользователей, спомощью которы мы можем разрешать или запрещать какие-либо действия над файлом: владелец, группа, остальные. Узнать список прав можно с помощью комманды `ls -l`
Права задаются с помощью команды `chmod` и достпные права как правило указывают цифрами:
* 0 - никаких прав
* 1 - выполнение
* 2 - запись
* 4 - чтение

Также существуют специальные права доступа:
1. SUID
2. SGID
3. Sticky-bit

**SUID** - специальный бит, который позволяет другим пользователям использовать файлы от имени владельца файла
**SGID** - специальный бит, который позволяет другим группам использовать файл от имени группы владельца файла
**Sticky-bit** - ползволяет пользователя создавать и удалять свобственные файлы в чужом каталоге, но манипулировать с файлами других пользователй может только владелец каталога.
## **Хранение файлов**. 
### Файлы.
**Файл** - именнованная область вторичной памяти, в которую можно записывать и из которой можно считывать данные.
Файлы по типу делятся на:
1. Обычные
2. Специальные (драйвера и т.д.)
3. Каталоги
Файлы имею три вида наименования:
1. Простое (название + расширение, если имеется)
2. Полное (от корневого каталога до простого названия файла)
3. Относительное (от другого каталога до простого названия файла)
### Фрагментация файлов.
**Фрагментация** - процесс дробления чего-то целого на фрагменты.
Выделяют два вида фрагментации файлов:
1. Внутреняя фрагментация
2. Внешняя фрагментация

**Внутреняя фрагментация** возникает когда область памяти, которая была выделена для некоторого блока данных, не полность занята и из пустого пространства образуется фрагмент, который невозможно использовать.
**Внешняя фрагментация** возникает когда в едином массиве памяти вознекают промежутки, слишком малые для заполнения едиными блоками файлов.
### Способы хранения файлов.
Выделяют три метода размещения файлов:
1. Непрерывное размещение
2. Цепочное размещение
3. Индексированное размещение

**Непрерывное размещение**
Особенность в том, что в момент создания файла в таблицу размещения файлов нам нужено записать только номер начального блока и длину файла (в блоках)
Преимущества:
1. Можно сразу прочитать несколько блоков
2. Легко получить доступ к отдельным блокам

Недостатки:
1. Внешняя фрагментация
2. Нельзя создать файл не зная его длину
3. Нужно совершать много операций чтобы найти все куски и сделать из них целый файл

**Цепочное размещение**
Размещение производится поблочно, при этом не требуется, чтобы блоки хранились последовательно. Также в каждом блоки хранится указатель на следующий.
Преимущества:
1. Таблица размещения требует только номер начального блока и длину файла
2. Блоки размещены не последовательно
3. Нет внешней фрагментации

Недостатки:
1. Последнии блоки могут быть не полностю заняты
2. Требуется доп инфа на управление указателем на следующий блок в каждом предыдущим
3. Если указатель теряется, то файл может быть не доступен

**Индексированное размещение**
В этом случае таблица размещения файлов содержит отдельный одноуровневый указатель для каждого файла, в котором последовательно указаны номера блоков файла.

Преимущества:
1. Нет внешней фрагментации
2. Блоки могут быть разных размеров
3. Обеспечивает последовательный и прямой доступ к файлам
### Файловая система.
Файловая система - совокупность всех файлов и операций над ними
### Структура современных файловых систем.
Структура совеременных ФС:
1. Суперблок (хранит в себе информацию о ФС)
2. Битовая карта (каждому блоку соответствует один бит: занят/свободен)
3. Дескрипторы файлов (служебная информация)
### Индексный узел.
Индексный узел содержит в себе следующие данные:
1. Тип файла
2. Права доступа
3. Идентификатор ФС
4. Идентификатор группы и владельца
5. Временные атрибуты
6. Размер файла
7. Адрес файла
8. Кол-во связей файла
### Принципы работы.
В суперблоке указан корневой каталог, в котором находим нужную нам каталог, из него извлекаем физический адрес, где он находится, извлекаем индесный узел, из которого извлекаем следующий каталог, и так по кругу пока не найдем что нужно.
### Жесткая и символическая связь.
Так как в дескрипторе нет имени файла, то один инод может иметь множество имен. Имя + ссылка на инод - **жесткая связь**. По сути удаление файла - удаление его жесткой ссылки, а создание - создание первой.
Недостатком жестких ссылок - ссылаться можно только в рамках одной ФС. Для обхода данной проблемы были созданы **сиволические ссылки** - специальный файл, в котором хранится адрес на другой файл. Единственным недостатком сиволической ссылки - переименование файла ломает ссылки.
### NTFS.
**NTFS** - файловая система Windows, которая поддерживает размеры кластера от 512 байт до 64 Кбайт, но неким стандартом является 4 Кбайта.
Диск при NTFS делится на две части:
1. 12% отводится для MTF - таблица файлов.
2. 88% обычное пространство для хранения.

Одна запись в MFT является индесным узлом. Если файл имеет малыый размер, то он распологается внутри самой MFT, но как только его размер станет достаточным для хранения в обычном пространстве обратно он уже не попадет в MTF.
Каждый файл NTFS представлен в виде потоков, для одного файла можно храниться несколько файловых поток, т.е. в одной фале может храниться совершенно разная информация, програмы при работе с такими файлами обращаются только к первому потоку.
## **Устойчивость файловых систем**. 
### Основные принципы обеспечение надежной работы ФС.
Устойчивые файловые системы - системы, которые стараются гарантировать, что их собственные структуры данных не будут поврежденны, если случится что-то плохое.
Основные принципы надежной работы ФС:
1. Диблирование файловых таблиц
2. Случайно их распределение на диске
3. Суперблок содержит флаг загрязнения - каждый раз, когда используем ФС, флаг поднимается икогда система размонитруется, флаг опускается. Если флаг не опустился, значит что-то не так и нужна проверка.
### Процесс восстановление ФС после сбоя.
Процесс востановления:
1. Все ли нормально в каталогах
2. Каждый блок и кластер принадлежит одному файлу
3. Кол-во блоков файла равняется его длине
4. Блоки не принадлежавшие файлам помечаются как свободные
### Типичные ошибки в ФС с индексными узлами.
Ошибки в ФС с индесными узлами:
1. Счетчик ссылок не соответствует реальному кол-ву
2. Иннод без ссылок не помечен как свободный
3. Иннод с ссылками помечен как свободный
### Устойчивость ФС к сбоям аппаратуры.
**Устройчивость к сбоям носителя** - специальный пулл кластеров, который всегда свободен, при этом, если какой-то кластер нестабильно себя ведет, то этот кластер помечается плохим и данные из этого кластера помещаются в кластер горячей замены.
### S.M.A.R.T.
**SMART** - технология самооценки состояния носителя.
Общие показатели:
1. Throughput performance - общая производительность диска.
2. Reallocated sectors count - количество переназначенных секторов
3. Power-on time count - сколько часов проработал
4. Reallocation event count - число операций переназначения
5. Raw read error rate - частота ошибок при чтении данных

Для **SSD**:
1. SSD life left - оставшийся жизненный цикл
2. Wear leveling count - износ диска
3. Erase fail count - попытки отчистки ячеек памяти
4. Percentage of life rated lifetime used - износ диска

Для **HDD**:
1. Spin-up time - время ужное для раскрутки.
2. Start/stop count - кол-во циклов включения-выключения
3. Seek error rate - частота ошибок при позиционирование головок
4. Spin-up retry count - числоповторных попыток раскрутки
## **Безопасность ОС**. 
### Основные принципы обеспечения безопасности ОС.
Основные принципы построения систем защиты:
1. Простота механизма защиты (потому что меньше шанс ошибки)
2. Постоянство защиты
3. Всеобъемлющий контроль (все части системы)
4. Не секретность проектирования (даже если украдут код, то все равно защита не пострадает)
5. Каждый объект должен однозначно идентифицироваться
6. Разделение полномочий
7. Минимальные полномочия (даем не больше, чем нужно для работы)
8. Максимальная обособленность (защита отдела от функций управления)
9. Защита памяти (чтоб когда прога выгрузится из ОЗУ, там было чисто)
10. Удобство для пользователя (если меняем пароль каждую неделю, то пользователя это заебет и он будет ставить простые пароли/записывать их куда-то)
11. Контроль доступа
12. Отчётность
13. Возможность наращивания защиты
14. Адекватность (салону ноготочков не нужна защита пентагона)
### Классификация компьютерных преступлений.
Перехват информации:
1. Непосредственный перехват
2. Уборка мусора – исследование данных, оставленных в памяти

Несанкционированный доступ к информации
1. За дураком – подключение к линии связи пользователя
2. За хвост – вариации дурака, перехват сигнала отключения, пользователь думаю, что он вышел, а злоумышленник работает
3. Абордаж (брутфорс) – перебирание паролей (что-либо связанное с перебором)
4. Неспешный выбор – в течение длительного времени медленно изучаем систему
5. Брешь – есть какая-то ошибка, используя которую можно получить доступ. Программы, использующие такие бреши – эксплоиты
6. Люки – возможности программы, не описанные в документации (обычно разрабы делают для тестов чего-то, например, чтоб не надо было логинется)
7. Маскарад – входит в систему по чужим данным (выдаем себя за другого)
8. Мистификация – когда пользователь работает с клоном системы (типа сайт сбера, но это просто такая же верстка)
9. Склад без стен – если произошел сбой, то мы можем начать его эксплуатировать
10. Скрытые каналы – получение данных, передаваемых между программами

Манипулирование данными:
1. Подмена данных – пользователь получает не то, что должен был
2. Подмена кода – изменение код программы
3. Троянский конь – тайное введение в программу функциональности, которая дает возможность сделать что-то плохое
4. Компьютерные вирусы
5. Салями – троянский конь, но в банковской сфере. При проведении операций отцепляем себе незаметную сумму
6. Логическая бомба – часто делают обиженные разработчики. Код, который срабатывает при определенном условии
### Вредоносное ПО и его классификация.
Вредоносное ПО классифицируют следующим образом:
1. Агенты ботнетов - зараженный компьютер, который получает команды от злоумышленника (используется для DDoS атак)
2. Эксплойты - утилиты, для эксплуатации уязвимости ПО
3. Бекдоры - удаленный доступ к компьютеру и управление им
4. Вирусы - внедряет свой код в другие приложения.
5. Руткиты - средства срытия вредоносной деятельности
6. Черви - способы распространяться по сетям
7. Трояны - выполняют скрытый функционал
8. Вымагатели и шифровальщики - каким-либо образом блокируют пользователя к его данным и просят выкуп за разблокировку.
### Идентификация, аутентификация.
**Идентификация** – это присвоение пользователю идентификатора (обычно логин)
**Аутентификация** – это проверка того, что идентификатор, который пользователь предъявил, действительно принадлежит ему (логин-пароль)
**Авторизация** – предоставление прав пользователю после аутентификации (кроме режима гостя)
Виды аутентификации:
1. Секретная информация
2. Материальный объект (например, usb с токеном)
3. Биометрические характеристики
4. Нечто, ассоциированное с ним (например, координаты)
### Способы авторизации.
Вся современная система контроля доступа выглядит как матрица, где в строках объекты, а в столбцах объекты и мы как бы ставим галочки, где кто что может
**Субъект** – принимает или передает информацию
**Объект** – создает или изменяет данные
Выделяют два способа авторизации:
1. Дискреционный - для каждого объекта отдельные права. Есть понятие домен защиты – это объект и все доступные операции. Команда su – смена домена. Обычно хранится не как матрица, а **ACL-список**: у каждого файла описано, кто что с ним может, либо у пользователя перечисляется, что он со всем может делать
2. Мандатный (полномочный) – у объектов есть уровни доступа и у субъектов есть уровни, куда им можно (типа как в фильмах). Нельзя считать из объекта, если у субъекта уровень ниже. Для записи часто наоборот, не может писать ниже, чтоб не сливать данные
