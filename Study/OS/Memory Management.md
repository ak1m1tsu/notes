Управление памятью - функция операционной системы, которая управляет основной памятью, выделяя и освобождая память для процессов, отслеживая использование памяти и обновляя состояние памяти по мере ее освобождения или не распределения. Эта функция обеспечивает эффективное использования ресурсов памяти, решая, какой процесс и в какое время получит память, и отслеживая расположение памяти.

## Process Address Space

Адресное пространство процесса представляет собой набор логических адресов, используемых процессом для ссылки на области памяти в своем коде. Размер адресного пространства зависит от используемой системы адресации и может варьироваться от 0 до теоретического максимума, например 2 гигабайта для 32-разрядной системы адресации.

Существуют три типа адресов:

- Символические адреса. Адреса, используемые в исходным коде. Имена переменных, константы и метки инструкций являются основными элементами символьного адресного пространства.
- Относительные адреса. Во время компиляции компилятор преобразует символические адреса в относительные адреса.
- Физические адреса. Загрузчик генерирует эти адреса в момент загрузки программы в оперативную память.

Виртуальные и физические адреса различаются схемой привязки адресов во время выполнения, а отображение виртуального адреса в физический во время выполнения выполняется блоком управления памятью (MMU), который представляет собой аппаратное устройство, использующее специальные механизмы для преобразования виртуального адреса в физический адрес.

## Static vs Dynamic Loading

Разница между статической и динамической загрузкой в компьютерных программах, где при статической загрузке полная программа компилируется и компонуется во время компиляции, а скомпилированная программа загружается в память для выполнения, в то время как при динамической загрузке для модулей предоставляются только ссылки во время компиляции, а динамические подпрограммы библиотеки загружаются в память только тогда, когда они необходимы программе во время выполнения.

## Static vs Dynamic Linking

Существует два типа методов компоновки, статическая компоновка и динамическая компоновка. Основное различие между ними заключается в том, что при статической компоновке модули, необходимые программе, объединяются в одну исполняемую программу, а при динамической компоновке, не требуется связывать фактический модуль или библиотеку с программой, вместо этого во время компиляции и компоновки предоставляется ссылка на динамический модуль. (DLL in Windows, Shared Object in Unix)

## Swapping

Swapping - механизм при котором процесс может быть временно выгружен из основной памяти (или перемещен) во вторичное хранилище (диск), тем самым сделать память доступной для других процессов. Чуть позже, система загружает обратно процесс из вторичного хранилища в главную память.

![[swapping]]

## Memory Allocation

Для достижения эффективного использования памяти выделения памяти должно выполняться методом разделов фиксированного размера, при этом каждый раздел содержит один процесс, что приводит к степени  мультипрограммирования, равной количеству разделов.

Выделяют два метода выделения памяти в ОС:

- Множественное выделение разделов
- Фиксированное выделение разделов

### Multiple partition allocation

В этом методе процесс выбирается из входной очереди и загружается в свободный раздел. Когда процесс завершается, раздел становится доступным для других процессов.

### Fixed partition allocation

В этом методе ОС поддерживает таблицу, в которой указано, какие части памяти доступны, а какие заняты процессам. Изначально вся память доступна для пользовательских процессов и считается одни большим блоком доступной памяти. Эта доступная память известна как "дыра" ("Hole"). Когда прибывает процесс и ему требуется память, мы ищем дыру, достаточно большую для хранения этого процесса. Если требование выполнено, мы выделяем память для обработки, в противном случае оставшаяся часть остается доступной для удовлетворения будущих запросов. При выделении памяти иногда возникают проблемы с динамическим выделением памяти, которые касаются того, как удовлетворить запрос размера n из списка свободных дыр. 

Есть несколько решений этой проблемы:

- First fit
- Best fit
- Worst fit

#### First Fit

В этом методе выбирается первая доступная свободная "дыра", которая соответствует требованиям процесса. Когда прибывает процесс, которому требуется память, система просматривает список доступных блоков памяти, начиная с самого начала, и выделает первый блок памяти, достаточно большой для хранения процесса.

#### Best Fit

В этом методе выбирается наименьшая "дыра", достаточно большая для выполнения требований процесса. Этот метод требует сканирования всего списка блоков памяти, если он не упорядочен по размеру. Преимущество этого метода в том, что он приводит к максимальному использованию памяти.

#### Worst Fit

В этом методе выделяется наибольшая доступная "дыра". Преимущество этого метода в том, что он дает самую большую остаточную "дыру", которую можно использовать для будущих процессов. Однако этот метод приводит к неэффективному использованию памяти, поскольку он оставляет неиспользованными меньшие "дыры".

## Fragmentation

Фрагментация определяется тем, что когда процесс загружается и удаляется после выполнения из памяти, он создает небольшую свободную "дыру". Эти "дыры" не могут быть назначены новым процессам, потому что "дыры" не объединены или не удовлетворяют требованиям процесса к памяти. Выделяют два вида фрагментации:

- Внутренняя фрагментация
- Внешняя фрагментация

### Internal fragmentation

Внутренняя фрагментация возникает, когда процессу выделяется больше блоков памяти, чем запрошенный размер. Из-за этого остается некоторое неиспользуемое пространство, что создает внутреннюю проблему фрагментации.

### External fragmentation

При внешней фрагментации у нас есть свободный блок памяти, но мы не можем назначить его процессу, потому что блоки не являются смежными.

Для решения проблемы внешней фрагментации используется уплотнение. В методе сжатия все свободное пространство памяти объединяется и составляет один большой блок. Таким образом это пространство может быть эффективно использовано другими процессами.

Другим решением внешней фрагментации - позволить логическому адресному пространству процессов быть не смежным, что позволяет процессу выделять физическую память столько, сколько ее доступно.

## Paging

Paging - схема управления памятью, которая устраняет необходимость непрерывного выделения физической памяти. Это схема позволяет физическому адресному пространству процесса быть не смежным.
