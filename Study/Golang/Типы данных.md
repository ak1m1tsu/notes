# Обычные типы

## Строки

Строка - неизменяемая последовательность байтов.

#### Длина строки и обращение по индексу

Встроенная функция `len()` возвращает кол-во байтов в строке, а операция *индексирования* возвращает *i*-ый байт строки s, где `0 <= i <= len(s)`

Если попытаться обратиться к байту вне допустимого диапазона, то вылетит ошибка `index out of range`:

```go
str := "hello, world" // string in ASCII encoding
c := str[len(str)] // panic: index out of range
```

Поскольку кодировка символы в кодировке UTF-8 могут содержать два и более байта, нежели в ASCII, следовательно обращение по *i*-му индексу не гарантирует получение *i*-го символа.

Для получения подстроки используют следующую конструкцию `str[i:j]`, которая возвращает байты исходной строки, начиная с *i*-го индекса и до (но не включая) *j*-ым индексом. Каждый из операндов `i` и `j` может быть опущен, и в этом случае используются значения по умолчанию - соответственно `0` и `len(str)`

```go
fmt.Println(str[:5]) // "hello"
fmt.Println(str[7:]) // "world"
fmt.Println(str[:]) // "hello, world"
```

#### Конкатенация

При помощи оператора `+` можно конкатенировать строки

```go
fmt.Println("goodbye" + str[5:]) // goodbye, world
```

Поскольку строки являются неизменяемыми, то все операции, которые пытаются изменить данные строки, не допускаются

```go
str[0] = 'L' // cannot assign to str[0]
```

#### Неизменяемость

Неизменяемость строки подразумевает, что две копии одной строки могут вполне безопасно разделять одну и ту же память, что делает копирование очень дешевой операцией. Аналогично строка `str` и подстроки могут разделять одну и ту же память из-за чего обращение к подстроки так же является дешевой операцией. Оба варианта не выделяют дополнительную память.

![](Excalidraw/golang_string-and-two-substrings)

### Строковые литералы

Управляющие последовательности:

- `\a`
- `\b`
- `\f`
- `\n`
- `\r`
- `\t`
- `\v`
- `\`
- `\"`
- `\\`

Неформатированный строковый литерал записывается с помощью обратных одинарных кавычек (\`...\`) вместо двойных. Внутри такой строки управляющие последовательности не обрабатываются.

### Строки и байтовые срезы

В основном для работы со строками использую 4 стандартных библиотеки: `bytes`, `strings`, `strconv`, `unicode`.

Пакет `strings` предназначен для поиска, замены, сравнения, обрезки, разделения и объединения строк.

Пакет `bytes` предназначен для аналогичных операций со срезами `[]byte`, которые имеет некоторые свойства, общие со свойствами строк. Из-за того, что строки неизменяемы, инкрементное построение строк может включать огромное кол-во выделений памяти и копирований. Для таких случаев используют структуру `bytes.Buffer`.

Пакет `strconv` предназначен для преобразования булевых значений, целых чисел и чисел с плавающей точкой в строки (и обратно).

Пакет `unicode` предназначен для классификации рун, преобразования одной руны в руну в указанном регистре.

# Составные типы

## Срез

Срез - легковесная структура данных, которая представляет доступ к базовому массиву. Она состоит из 3-х компонентов:

1. Указатель - указывает на первый элемент массива, доступный через срез (не обязательно первый элемент массива).
2. Длина - текущее кол-во элементов среза, не может превышать емкость.
3. Емкость - количество элементов между началом среза и концом базового массива

Несколько срезов могут использовать один и тот же базовый массив. Срезание за пределы `cap(slc)` вызывает панику, вырезание за пределами `len(slc)` приводит к расширение среза.

В отличие от массивов срезы не являются сравнительными, поэтому не возможно использовать оператор ` == `. Для сравнения двух срезов байтов используют метод `Equal` пакета `bytes`, а для остальных придется самостоятельно.

Использовать операторы `!=` и `==` нельзя для срезов из-за следующих причин:

- Элементы среза являются косвенными, что позволяет содержать срезу самого себя. Хотя есть методы обработки, но они все дорогие, неэффективные и не очевидные.
- В силу косвенности элементов фиксированное значение среза может содержать различные элементы в разные моменты времени при изменении содержимого базового массива.

## Map

Хэш-таблица - неупорядоченная коллекция ключ-значение, в которой все ключи различны, а операции обновления, удаления используют практически константное кол-во значений ключей.

**Map** - ссылка на хэш-таблицу, а тип записывается как `map[K]V`, где `K` и `V` являются типами его ключей и значений. Тип ключа `K` должен быть сравниваемым с помощью оператор `==`, чтобы отображение могло проверить, равен ли данный ключ одному из имеющихся в нем.

```go
ages := map[string]int{
	"alice": 31,
	"charlie": 34,
}
```

Удаление возможно при помощи встроенной функции `delete`

```go
delete(ages, "alice")
```

Однако элементы мапы не являются переменными, и мы не можем получить их адреса:

```go
_ = &ages["bob"] // error: cannot take address of ages["bob"]
```

Одна из причин, по которым не возможно получить адрес элемента мапы: с ростом мапы может быть выполнено повторное хеширование элементов в новые места хранения, что потенциально делает адреса не действительными.

Для перечисления всех пар "ключ-значение" используют циклы по диапазону.

```go
for name, age := range ages {
	// . . .
}
```

Порядок итераций не определен; различные реализации могут использовать разные хэш-функции, что приведет к иному порядку. Это сделано преднамеренно; варьируемые последовательности помогают писать программы, которые одинаково надежны в разных реализациях языка.

Отличить несуществующий элемент от элемента, который имеет нулевое значение, можно с помощью следующего теста:

```go
if age, ok := ages["bob"]; !ok { /* ... */ }
```

#### Внутренняя структура `map`

![](Excalidraw/map-structure)

Map - состоит из 2х частей `Header`, который хранит в себе общую информацию о map:

- `Size` - кол-во элементов в `map`
- `Log(buckets count)`, который хранится в виде логарифма. На это есть две причины
	- Возможность хранить более маленькие значения - экономия на памяти
	- Ускоряет побитовые операции, который проводятся с этим оператором
- `*Buckets` - вторая часть `map`, указатель на список бакетов. Каждому бакету соответствует **LOB Hash** (Low order bits), который помогает искать бакет из предоставленной хэш-функции.
- `Hash seed`, который позволяет выполнить условие безопасности, т.е. усложняет подбор ключей таким образом, чтобы заполнить один `Bucket` не больше чем другие.

#### LOB (Low order bits) Hash

Допустим у нас есть какой-то ключ, мы применяем к нему хэш-функцию и получаем очень большое число, а бакетов у нас небольшое число. Чтобы сопоставить это число к конкретному бакету, нужно вычислить остаток от деления этого числа от кол-ва бакетов, так как остаток будет соответствовать конкретному бакету. 

Для ускорения вычислений операций все происходит побитово, т.е. число полученное из хэш-функции приводится к двоичному виду, далее чтобы получить остаток от деления потребуется `Log(buckets count)`, чтобы получить кол-во бакетов нужно **2** возвести в степень **n**, которой будут соответствовать **n** бита младшего порядка. Эти биты и будут являться `LOB Hash`

#### Структура бакета

![](map-backet-structure)

Структура бакета делится на две части:

- 8 слотов для **HOB Hash** (старших битов хэша). Они нужны для быстрой проверки наличия ключа в бакете. В каждом бакете может храниться не больше 8 значений.
- Ключи со значениями

#### Переполнение бакета и эвакуация данных из бакета

Если возникла ситуация когда в бакет нужно положить 9 значение, то создается новый бакет и ссылка на него сохраняется в изначальном бакете.

Когда среднее значение заполненности бакетов в `map` составляет `6.5` происходит эвакуация данных, т.е. создается новый список бакетов, который в 2 раза больше чем предыдущем и данные из старых будут скопированы в новые в тем моменты, когда будут производиться операции сохранения или удаления ключей из `map`

## Структура

***Структура*** - агрегированный тип данных, объединяющий нуль и более именованных значений произвольных типов в единое целое.

Имя поля структуры экспортируется, если оно начинается с прописной буквы; это основной механизм управления доступом в Go. Структурный тип может содержать комбинацию экспортируемых и не экспортируемых полей.
