# Goroutine

Горутина - облегченный поток и функция, которая выполняется одновременно с остальной частью программы. 

Они похожи на потоки в других ЯП, но более легкие и эффективные. Многие горутины могут выполняться в одном потоке ОС, что означает, что они требуют гораздо меньше памяти и могут создаваться и уничтожаться гораздо быстрее, чем традиционные потоки.

Горутины создаются с использованием ключевого слова `go`, за которым следует вызов функции. Когда горутина создается, она сразу же запускается в фоновом режиме, а программа продолжает выполняться в основном потоке. Они могут общаться друг с другом и синхронизировать свои действия с помощью каналов.

## Планировщик горутин

В Go есть собственный планировщик, который использует метод *m:n-планирование*, потому что он планирует выполнение *m горутин* на *n потоках* операционной системы.

В отличие от планировщика потоков ОС планировщик Go вызывается не периодически аппаратным таймером, а неявно некоторыми конструкциям языка. Например, когда горутина вызывает `time.Sleep` или блокируется операцией канала или мьютекса, планировщик переводит ее в спящий режим и запускает другую горутину до тех пор, пока не наступит время активировать первую. Из-за того, что не приходится переключать контекст процессора переключение горутин гораздо дешевле чем, переключение потоков.

# Channel

### Свойства канала

У каналов в Go следующие свойства:

- goroutine-safe
- хранение элементов, семантика FIFO
- передача данных между горутинами
- блокировка горутин

### В какой области памяти хранятся каналы?

```go
ch := make(chan int, 4)
```

Каналы создаются для того чтобы передавать их между горутинами, чтобы эти горутины могли общаться друг с другом. Поэтому единственное что для этого подходит это `Heap` (куча)

![](Excalidraw/golang_channel-structure)

Для реализации goroutine-safe и хранение элементов по FIFO нам потребуются только `buf`, `recvx`, `sendx`, `lock`

![](Excalidraw/golang_goroutine-safe)

### Как горутины передают сообщения через каналы

Например, у нас есть 2 горутины: получатель и отправитель. Представим, что отправитель первым начал операции и отправил сообщение получателю. В этот момент будет заблокирован мютекс канала и сообщение будет скопировано в буфер, после копирования канал разблокирует мютекс. Далее получатель обращается к каналу, также блокируется мютекс, значение из буфера копируется получателю и в конце происходит разблокировка мютекса.

#### Алгоритм работы с buffered channel

Если возникла ситуация когда во время передачи сообщений в буфер канала он переполняется, происходит блокировка отправителя до тех пор, пока в буфере не появится свободное место. После такой блокировки горутина попадает в очередь `sendq`. Там она помещается в структуру `sudog` в значение `G`, а значение, которая она отправляла помещается в значение `elem`.

Чтобы пробудить спящую горутину наш получатель должен начать читать из канала данные. Как только он прочитает из заполненной очереди значение ячейка в очереди освободится, на второй итерации `recvx` обращается к `sendq` и перемещает значение `elem` из `sudog` и перемещает `sendx` на следующую ячейку. В конце `recvx` займется пробуждением спящей горутины.

В ситуации когда получатель пришел первым, если наш буфер пуст, то получатель уходит в паузу и попадает в очередь `recvq` которая аналогична `sendq`. Получатель так же помещается в структуру `sudog` атрибут `G`, а атрибут `elem` будет представлять из себя область памяти в которую нужно будет передать данные прочитанные из канала. Здесь сделана оптимизация, которая позволяет отправителю напрямую отдать значение спящему получателю заодно пробудив его.

#### Алгоритм работы с unbuffered channels

Так как нет буфера, через который получатель и отправитель могли бы общаться, отправлять сообщения приходится напрямую из стека отправителя в стек получателя.

#### Select

```go
select {
	case <- chanA:
		handlerA()
	case <- chanB:
		handlerB()
	default:
		defaultHandler()
}
```

Первое что произойдет во время работы `select` - случайная сортировка `cases`, дальше они будут последовательно обходиться. При помощи `select` мы делаем чтение из каналов неблокирующей операцией, так как если бы она была блокирующей, то мы не смогли бы обойти все `case`.

#### Closing

Алгоритм закрытия канала:

- Инициализирован ли канал? Если нет, то вызывается `panic`
- Блокировка мютекса
- Проверка закрыт ли канал? Если да, то вызывается `panic`
- Отмечаем канал как `closed = true`
- Отпускаем всех получателей
- Отпускаем всех отправителей. Они вызовут `panic`
- Разблокировка мютекса
- Разблокировка всех ждущих горутин